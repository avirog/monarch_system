---
globs: *.nxs
alwaysApply: false
---
# Nexus Language Rules for Cursor

## Language Overview
Nexus is a domain-specific language for programming systems from two perspectives:
- **Product Managers** program WHAT the system should do and WHY (product entities and requirements)
- **Software Architects/Engineers** program HOW the system works (design entities and implementation)

The language combines structured syntax with free-text descriptions. Each perspective uses the same language but defines different entities:
- Product entities describe features, user interactions (how users engage with the product), and business concepts visible to product
- Engineering entities describe technical components, modules, and infrastructure that may be invisible to product
- These perspectives can coexist in the same file or be maintained separately

## File Structure
- Files should have `.nxs` extension
- Start with catalog declaration
- Follow with entity definitions and scenarios
- Rules belong to entities (not top-level)

## Syntax Rules

### 1. Preamble (Required)
```nexus
catalog: CatalogName

imports:
    com.example.Module1
    com.example.Module2 as Alias
```

### 2. Entity Definition
```nexus
entity: EntityName
role: platform|language|actor|module|component|service|struct
purpose:
    - Single line purpose statement (plain text, no references)
    - Multi-line purpose with bullet points (plain text, no references)

properties:
    property_name: Description (plain text, no references)
    another_property: Another property description

actions:
    action_name: Description of what this action does (plain text, no references)
    another_action: Another action description

relations:
    @TargetEntity: Description of relationship (plain text, no references)
    @AnotherEntity:
        - Multi-line relation description (plain text)
        - Each bullet describes the relationship

rules:
    RuleName: Description of the business rule or constraint (plain text, no references)
    AnotherRule: Another rule description
```

### 3. Scenarios
```nexus
scenario: ScenarioName
Free-form description of the scenario.
Can use Given/When/Then/And format, or when-case, or any narrative style.
```

## Key Syntax Elements

### Entity References
The language supports entity references using the `@` prefix, but **only in specific contexts**:

1. **Direct entity reference**: `@EntityName`
   - References an entity in the current catalog
   
2. **Catalog-qualified reference**: `@catalog.entity`
   - References an entity from an imported catalog

**Where references are allowed:**
- ✅ **Relations section**: `@TargetEntity: description` where description clearly explains who gives/receives/uses what
- ✅ **Scenarios**: References can appear in scenario steps

**Where references are NOT allowed:**
- ❌ Purpose statements (plain text only)
- ❌ Properties (plain text only)
- ❌ Actions (plain text only)
- ❌ Rules (plain text only)

**Usage notes:**
- Referenced entities don't need to be defined in order
- Use catalog-qualified references for imported entities
- Write relation descriptions that clearly express who gives/receives/contains/uses what


### Property Types
- Basic types: `String`, `Number`, `Boolean`
- Custom types: `CNAME` (alphanumeric identifiers)
- Entity Types: `EntityName` (without @ prefix - plain text type name)
- Property descriptions are plain text (no entity references)


## Programming Perspectives

### Product Manager Perspective (WHAT/WHY)
Product managers define **product entities** - things visible and relevant to product:
- **Entities**: User-facing features, capabilities, business concepts, user journeys
- **Purpose statements**: Describe what the entity does and why (plain text)
- **Relations**: `@TargetEntity: description` - clearly express who gives/receives/uses what
- **Scenarios**: Define user stories with entity references in steps
- **Rules**: Capture business logic and constraints (plain text)
- **Entity roles**: Typically `actor`, `service` or any other from user perspective
- Free-text descriptions explain the "why" behind product decisions

Example (product specification):
```nexus
catalog: CheckoutProduct

entity: PaymentFlow
role: service
purpose:
    - Enables fast and reliable payment processing
    - Provides clear feedback and error recovery

relations:
    @Customer: processes payments submitted by customers
    @PaymentMethod: validates and charges payment methods for customers

rules:
    FastProcessing: Must complete within 3 seconds
    ErrorRecovery: Must provide clear feedback on failures

entity: Customer
role: actor
purpose: Represents users purchasing products

scenario: SuccessfulPurchase
Given @Customer completes checkout and has valid payment credentials
When @PaymentFlow processes the payment
Then payment is processed within 3 seconds and returns immediate confirmation
```

### Software Architect/Engineer Perspective (HOW)
Engineers define **design entities** - technical components of the implementation:
- **Entities**: Services, modules, components, databases, APIs, infrastructure
- **Properties**: Data structures, types, constraints, configuration (plain text)
- **Actions**: Operations, interfaces, APIs (plain text)
- **Relations**: `@TargetEntity: description` - clearly express who gives/receives/uses what
- **Rules**: Technical constraints and design rules (plain text)
- **Entity roles**: `platform`, `module`, `component`, `service`, `struct`... from technical perspective
- Free-text descriptions explain technical decisions and patterns

Example (design specification):
```nexus
catalog: PaymentSystem

imports:
    external.PaymentProvider
    monitoring.MetricsCollector

entity: PaymentGateway
role: component
purpose: 
    - External integration layer for payment processing
    - Handles transaction execution and metrics reporting

properties:
    max_retries: Number, maximum retry attempts, default 3
    api_version: String, provider API version
    metrics_enabled: Boolean, enable metrics reporting, default true

actions:
    authorize_payment: Validates available funds
    capture_payment: Executes the transaction
    handle_webhook: Processes provider notifications

relations:
    @external.PaymentProvider: sends transaction requests to provider and receives responses
    @MetricsCollector: sends transaction metrics and performance data to collector

rules:
    RetryPolicy: Maximum 3 retry attempts per transaction
    MetricsRequired: All transactions must be reported

entity: PaymentDatabase
role: module
purpose: Persistent storage for transaction history and audit logs

properties:
    gateway: PaymentGateway, gateway instance reference

actions:
    log_transaction: Records transaction results
    query_metrics: Retrieves aggregated metrics

relations:
    @PaymentGateway: receives and stores transaction records from gateway
    @MetricsCollector: provides historical transaction data to collector for analysis

```

## Best Practices

### 1. Naming Conventions
- Use PascalCase for entity names: `PaymentFlow`, `UserService`
- Use snakeCase for properties and actions: `max_retries`, `authorize_payment`
- Use descriptive names that clearly reflect purpose and domain

### 2. Purpose Statements
- **Product perspective**: Focus on business value and user impact
- **Architect perspective**: Focus on technical responsibility and system role
- Start with action verbs for clarity
- Be concise - avoid repeating information from other sections
- **Important**: Purpose statements are plain text - do NOT use entity references
- Use bullet points for multiple distinct concerns
- Put relationship details in the `relations` section, not in purpose

### 3. Relations
- Define explicit relationships in the `relations` section
- Format: `@TargetEntity: description` where description clearly explains the relationship
- **Write clear relationship descriptions** that answer: who gives/receives/contains/uses/depends-on what from/to whom
  - Good: `@Database: stores transaction data in database`
  - Good: `@PaymentProvider: receives payment requests from this service`
  - Good: `@Customer: processes payments for customers`
  - Good: `@MetricsCollector: sends performance metrics to collector`
  - Avoid: `@PaymentProvider: handles payments` (unclear who does what)
- The description is plain text - no additional `@` entity references allowed
- Use entity names (without `@`) in descriptions when needed for clarity
- Use `@EntityName` for same catalog, `@catalog.entity` for imports
- Support single-line or multi-line bullet format

### 4. Entity References
- **Only use references in relations and scenarios**
- Use simple references `@EntityName` when referring to entities in the same catalog
- Use catalog-qualified references `@catalog.entity` for imported entities
- Keep references consistent across the specification
- Group related entities together


## Common Mistakes to Avoid
- ❌ Using `@Entity` references in purpose, properties, actions, or rules
- ❌ Defining rules at top-level (they belong inside entities)
- ❌ Repeating the same information in purpose and relations
- ❌ Forgetting the catalog declaration
- ❌ Inconsistent indentation

## Must Do
- ✅ Always include catalog declaration at the top
- ✅ Use `@` prefix for entity references (only in relations and scenarios)
- ✅ Define rules within the entities they apply to
- ✅ Use the `relations` section for explicit entity relationships
- ✅ Keep descriptions concise and avoid redundancy

## File Organization

### Recommended Structure
- **Product specifications**: Separate files defining product entities (e.g., `product-checkout.nxs`)
- **Engineering specifications**: Separate files defining design entities (e.g., `design-payment-service.nxs`)
- One file per major domain or feature area
- Group related entities together within each file
- Use imports for shared definitions across files
- Define rules within the entities they apply to
- Use explicit `relations` sections to define entity relationships

### Key Principles
- Product and engineering entities are independent - they don't need to match
- Product may define entities engineering doesn't have (user journeys, business concepts)
- Engineering may define entities product doesn't see (infrastructure, internal services)
- Both perspectives use the same Nexus language syntax
- Files can be separate (recommended) or combined based on team workflow
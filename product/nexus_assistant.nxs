
catalog: NexusAssistant

entity: NexusAssistant
role: service
purpose:
    - Bridges the gap between product specifications and implementation by providing contextual guidance
    - Enables product managers to manage requirements and create new features effectively
    - Enables developers to manage system design that supports product needs and to implement features
    - Enables AI agents to understand exact implementation requirements from product and architectural designs
    - Automatically discovers which code implements which specifications using AI analysis
    - Shows developers and product managers how requirements connect to actual implementation
    - Reduces miscommunication between product vision, system design and technical execution

properties:
    productView is @ProductView, collection of product-level views managed by the assistant
    systemDesignView is @SystemDesignView, collection of system design views managed by the assistant
    componentImplementations is @ComponentImplementation, collection of component-level implementations managed by the assistant
    mcpInterface is @MCPServerInterface, protocol interface for external AI agent access

actions:
    provideImplementationContext: Generates @ImplementationContext on-demand by synthesizing product requirements and architectural decisions for specific implementation needs
    analyzeSpecifications: Examines @ProductView and @SystemDesignView to identify gaps, conflicts, or missing details
    traceRequirement: Traces a requirement from @ProductView through @SystemDesignView to @ComponentImplementation and actual source code
    findImplementingCode: Shows which source code files and functions implement a given specification
    findSpecificationForCode: Shows which product requirements and design specs explain why given code exists (traces backward through layers)
    navigateLayers: Provides context following the layered flow: product requirements → design specifications → implementation details
    identifyRelatedEntities: Determines which entities may be affected by changes or are important in a given context
    assessCoverage: Reports which requirements have been implemented and which remain as gaps
    manageRequirements: Helps organize, track, and maintain @ProductView for product managers
    manageSystemDesign: Helps organize, track, and maintain @SystemDesignView for developers
    validateFeatureReadiness: Checks if new feature specifications are complete and ready for design and implementation
    searchSpecifications: Understands natural language questions and finds relevant specifications, entities, and relationships semantically without requiring exact names

entity: ProductManager
role: actor
purpose:
    - Defines product requirements and creates new features in @ProductView
    - Manages the product vision and user-facing capabilities
    - Needs support to ensure specifications are complete and aligned with existing system

properties:
    assistant is @NexusAssistant, the assistant service used for requirements management

actions:
    defineRequirements: Creates and maintains @ProductView for new and existing features
    createFeature: Specifies new features and user capabilities in product views
    queryExistingFeatures: Asks @NexusAssistant about existing product capabilities and implementations

entity: Developer
role: actor
purpose: 
    - Software engineer who designs system architecture and implements features
    - Creates and maintains @SystemDesignView to support product needs
    - Requires clear, actionable guidance on how to translate product requirements into system design and code

properties:
    assistant is @NexusAssistant, the assistant service used for system design and implementation guidance

actions:
    queryAssistant: Asks @NexusAssistant for system design or implementation guidance on specific features or questions
    designSystem: Creates and maintains @SystemDesignView to support product requirements
    implementFeature: Writes code to implement features based on specifications and guidance received

entity: AIAgent
role: actor
purpose:
    - Autonomous assistant that helps manage product requirements, system design, and code implementation
    - Works across all three layers: product, design, and implementation
    - Needs precise context and constraints to generate appropriate artifacts

properties:
    assistant is @NexusAssistant, the assistant service used for product, design, and implementation guidance

actions:
    manageProductRequirements: Creates and maintains @ProductView based on user needs and business requirements
    manageSystemDesign: Creates and maintains @SystemDesignView to support product requirements
    requestContext: Requests @ImplementationContext from @NexusAssistant for a specific feature
    generateCode: Creates code that meets product and architectural requirements based on provided context

entity: ImplementationContext
role: component
purpose:
    - Synthesized guidance that combines product requirements with architectural decisions
    - Provides specific, actionable implementation instructions
    - Generated by @NexusAssistant for @Developer and @AIAgent consumption

entity: ProductView
role: component
purpose:
    - Represents the user-facing features and business capabilities
    - Describes WHAT the system does from customer and business perspective
    - Contains user journeys, business rules, and value propositions
    - Written in Nexus language focusing on WHY features exist

properties:
    systemDesigns is @SystemDesignView, collection of system designs that realize this product

entity: SystemDesignView
role: component
purpose:
    - Represents the technical architecture and system structure
    - Describes HOW the system is organized at high level
    - Contains modules, services, data flows, data struct, schemas, and integration patterns
    - Written in Nexus language focusing on architectural decisions and patterns

properties:
    componentImplementations is @ComponentImplementation, collection of component implementations that realize this design

entity: ComponentImplementation
role: component
purpose:
    - Represents specific code-level components and their implementation details
    - Describes the actual technical implementation of features
    - Contains APIs, data structures, algorithms, and technical constraints
    - Written in Nexus language focusing on concrete implementation requirements

entity: MCPServerInterface
role: service
purpose:
    - Exposes @NexusAssistant capabilities to external AI agents and tools via Model Context Protocol
    - Enables third-party AI systems to query product specifications and system designs
    - Provides standardized protocol interface for both internal and external agent integration
    - Allows external tools to request @ImplementationContext and navigate specification layers

properties:
    exposedOperations is @NexusAssistant, subset of @NexusAssistant actions available through MCP protocol

actions:
    serveMCPRequest: Handles incoming MCP protocol requests from external AI agents
    exposeContext: Provides @ImplementationContext through MCP interface
    exposeNavigation: Enables specification layer navigation for external clients

scenario: DeveloperSeeksImplementationGuidance
Given a developer working on a new feature
When they query the @NexusAssistant with a specific implementation question
Then the assistant analyzes both @ProductView and @SystemDesignView
And shows existing code that implements similar features
And provides contextual implementation guidance 
And includes specific code patterns, constraints, and business logic requirements

scenario: AIAgentGeneratesCode
Given an @AIAgent tasked with implementing a feature
When it requests implementation context from @NexusAssistant
Then the assistant provides structured guidance including:
    - Business rules that must be enforced
    - Technical patterns to follow
    - Integration requirements with existing components
    - Validation and error handling requirements
And the AI agent can generate code that meets both product and architectural requirements

scenario: SpecificationAlignment
Given @ProductView and @SystemDesignView that may have gaps or conflicts
When @NexusAssistant analyzes them
Then it identifies missing implementation details
And highlights potential conflicts between product and design views
And suggests clarifications needed before implementation can proceed

scenario: MultiLayerNavigation
Given a developer or AI agent needs to understand a feature
When they query @NexusAssistant about the feature
Then the assistant provides context across all three layers in sequence:
    - @ProductView: WHY the feature exists and WHAT it does for users
    - @SystemDesignView: HOW the product requirements are translated into technical architecture
    - @ComponentImplementation: Specific technical details and code-level requirements that realize the design
And enables navigation between layers following the product → design → implementation flow

scenario: TraceRequirementToCode
Given a business requirement defined in @ProductView
When a developer needs to implement it
Then @NexusAssistant traces the requirement through @SystemDesignView to specific @ComponentImplementation
And shows which source code files and functions implement which product features
And provides implementation guidance consistent across all three layers

scenario: FindWhyCodeExists
Given a developer looking at unfamiliar code
When they ask @NexusAssistant why this code exists
Then the assistant traces backward from code through @SystemDesignView to @ProductView
And shows the design decisions that translated requirements into this implementation
And reveals the product requirements that justify this code
And explains the business value delivered by this code

scenario: IdentifyImplementationGaps
Given @ProductManager reviewing product roadmap
When they query @NexusAssistant about feature status
Then the assistant shows which requirements are fully implemented
And highlights which requirements have no corresponding code yet
And helps prioritize implementation work based on gaps

scenario: AssessChangeImpact
Given @Developer planning to modify code
When they query @NexusAssistant about potential impacts
Then the assistant identifies which requirements might be affected
And shows which other code depends on the changes
And warns about risks to product features

scenario: ExploratoryNaturalLanguageSearch
Given a developer or product manager unfamiliar with the system
When they ask "What components are responsible for parsing specifications?"
Then @NexusAssistant understands the semantic intent without requiring exact entity names
And searches specifications using meaning and context, not exact text matching
And returns relevant components that handle specification parsing
And explains how these components work together to accomplish parsing

scenario: SemanticLayerDiscovery
Given an @AIAgent exploring the system architecture
When it asks "How does the system expose functionality to AI agents?"
Then @NexusAssistant interprets the question semantically
And identifies design entities related to API exposure and agent integration
And returns components that handle external agent access and their relationships
And provides context about how these components enable integration

scenario: IntentBasedEntitySearch
Given a user asking about capabilities without knowing exact terminology
When they query "Find all entities in the design layer"
Then @NexusAssistant understands they want to browse entities by layer
And retrieves all design-layer entities from the knowledge graph
And presents them with their roles, purposes, and key relationships
And enables further exploration of discovered entities

scenario: FuzzyConceptMatching
Given a query with approximate or alternative terminology
When user asks "What handles file watching?"
Then @NexusAssistant matches concepts like "file watching" to related entities
And finds the component that monitors file changes
And explains the entity's purpose and file watching capability
And shows scenarios demonstrating the file watching behavior

rule: ContextualAccuracy
@NexusAssistant must only provide implementation guidance that is consistent with both product requirements and architectural constraints

rule: TraceabilityRequirement
Every implementation recommendation must be traceable back to specific product requirements or architectural decisions

rule: RealTimeAnalysis
@NexusAssistant must analyze specifications in real-time and provide up-to-date guidance based on the latest versions

rule: MultiPerspectiveIntegration
Implementation context must synthesize both product manager perspective (WHAT/WHY) and architect perspective (HOW) into actionable developer guidance

rule: ThreeLayerConsistency
Information must remain consistent across @ProductView, @SystemDesignView, and @ComponentImplementation layers

rule: LayeredTraceability
Product requirements connect to code through design specifications, never directly - every @ProductView requirement traces through corresponding @SystemDesignView elements to reach @ComponentImplementation and actual code

rule: BidirectionalTraceability
The assistant must support tracing both top-down (from product requirements through design to actual code) and bottom-up (from code through design to product value and business justification)

rule: AutomaticTraceDiscovery
@NexusAssistant must automatically discover connections between specifications and code without requiring manual tagging or linking

rule: CoverageVisibility
Product managers and developers must be able to see which requirements have been implemented and which have gaps

rule: ImpactAwareness
When code or specifications change, @NexusAssistant must identify and communicate what else might be affected

rule: RelationalImpactAnalysis
@NexusAssistant must identify and present all related entities that may be affected by changes or whose relations are important to consider in any context, including implementation, design decisions, product changes, or understanding existing features

rule: SemanticSearchCapability
@NexusAssistant must support natural language queries that don't require exact entity names - searches must understand user intent, match concepts semantically, and return relevant results based on meaning rather than text matching alone
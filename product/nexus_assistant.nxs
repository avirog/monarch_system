
catalog: NexusAssistant

entity: NexusAssistant
role: service
purpose:
    - Bridges the gap between product specifications and implementation by providing contextual guidance
    - Rapidly finds and retrieves relevant specification fragments from any layer using deep semantic understanding of questions
    - Transforms natural language questions into multiple search variations that match documentation style, improving search accuracy across vocabulary differences
    - Precisely matches queries to specific statements, actions, properties, and rules rather than entire entities for accurate results
    - Returns exact matching content with full context including parent entity and all referenced entities
    - Deeply understands individual statement semantics and relationships to answer contextual queries with precision
    - Enables product managers to manage requirements and create new features effectively
    - Enables developers to manage system design that supports product needs and to implement features
    - Enables AI agents to understand exact implementation requirements from product and architectural designs
    - Automatically discovers which code fragments implement which specification fragments using AI analysis
    - Shows developers and product managers how specific requirements connect to actual implementation code
    - Reduces miscommunication between product vision, system design and technical execution
    - Provides simple web-based viewer interface enabling users to explore all capabilities through browser without coding
actions:
    provideImplementationContext: Generates implementation context on-demand by synthesizing product requirements and architectural decisions for specific implementation needs
    analyzeSpecifications: Examines product view and system design view to identify gaps, conflicts, or missing details
    traceRequirement: Traces requirements bidirectionally - from product view through system design view to code, or backward from code to product value
    identifyRelatedEntities: Determines which entities may be affected by changes or are important in a given context
    assessCoverage: Reports which requirements have been implemented, validates trace quality with confidence scores, and highlights gaps needing review
    manageRequirements: Helps organize, track, and maintain product view for product managers
    manageSystemDesign: Helps organize, track, and maintain system design view for developers
    validateFeatureReadiness: Checks if new feature specifications are complete and ready for design and implementation
    searchSpecifications: Transforms user questions into multiple declarative search phrases, then semantically finds relevant specification fragments from any layer by matching against individual statements with each phrase, returning precise results with parent entity context, referenced entities, and which search phrase matched
    discoverEntities: Lists and explores entities across catalogs, filtered by layer, role, catalog, or context
    exploreEntity: Provides detailed information about a specific entity including its purpose, properties, actions, and relationships
    browseEntityGraph: Enables navigation through the entity relationship graph to understand system structure and dependencies
    explainTraceRationale: Provides detailed explanation of why a trace link exists to generate human-readable justifications
    resolveAmbiguousTraces: Uses LLM reasoning to clarify which specification truly connects to which code when similarity alone is insufficient
    serveWebInterface: Provides browser-based viewer with tabs for graph visualization, semantic search, entity browsing, trace links, and code exploration
relations:
    @ProductView: NexusAssistant reads, analyzes, and helps manage product specifications stored in this view
    @SystemDesignView: NexusAssistant reads, analyzes, and helps manage system design specifications stored in this view
    @ComponentImplementation: NexusAssistant reads and analyzes implementation code stored in this view
    @IntelligentTraceEngine: NexusAssistant uses this engine to discover and validate trace links between specifications and code
    @MCPServerInterface: NexusAssistant exposes its capabilities to external AI agents through this protocol interface
    @ImplementationContext: generates this context by synthesizing product and system design specifications for developers
    @WebInterface: NexusAssistant provides browser-based interface for users to access all capabilities visually

rules:
    ContextualAccuracy: NexusAssistant must only provide implementation guidance that is consistent with both product requirements and architectural constraints
    TraceabilityRequirement: Every implementation recommendation must be traceable back to specific product requirements or architectural decisions
    RealTimeAnalysis: NexusAssistant must analyze specifications in real-time and provide up-to-date guidance based on the latest versions
    MultiPerspectiveIntegration: Implementation context must synthesize both product manager perspective (WHAT/WHY) and architect perspective (HOW) into actionable developer guidance
    ThreeLayerConsistency: Information must remain consistent across ProductView, SystemDesignView, and ComponentImplementation layers
    LayeredTraceability: Product requirements connect to code through design specifications, never directly - every ProductView requirement traces through corresponding SystemDesignView elements to reach ComponentImplementation and actual code
    BidirectionalTraceability: The assistant must support tracing both top-down (from product requirements through design to actual code) and bottom-up (from code through design to product value and business justification)
    CoverageVisibility: Product managers and developers must be able to see which requirements have been implemented and which have gaps
    RelationalImpactAnalysis: When code or specifications change, NexusAssistant must identify and communicate all related entities that may be affected or whose relationships are important to consider in any context, including implementation, design decisions, product changes, or understanding existing features
    SemanticSearchCapability: NexusAssistant must support natural language queries that don't require exact entity names - searches must understand user intent, match concepts semantically, and return relevant results based on meaning rather than text matching alone
    EntityDiscoverability: Users must be able to discover entities without prior knowledge of entity names - NexusAssistant must provide browsing, filtering, and exploration capabilities by catalog, layer, role, and context to enable understanding of the monitored system
    AccuracyAndCompleteness: NexusAssistant must prioritize accuracy, precision, and completeness over response speed - returning all correct, relevant entities is more important than fast responses - but speed should be optimized where it doesn't compromise quality
    DeepFragmentUnderstanding: NexusAssistant must analyze and understand the complete semantic meaning of each specification fragment including its statement text, parent entity context, and all referenced entities - enabling precise matching at statement level rather than coarse entity-level matching
    CrossLayerSearch: NexusAssistant must seamlessly search across ProductView, SystemDesignView, and ComponentImplementation layers simultaneously when questions span multiple perspectives, returning unified results that show connections between layers
    IntelligentRelevanceRanking: Search results must be ranked by contextual relevance considering semantic similarity, entity richness, relationship centrality, layer appropriateness, and indirect connections - most relevant entities must appear first with clear relevance explanations
    SemanticPrecision: NexusAssistant must use appropriate similarity thresholds to balance recall (finding all relevant entities) and precision (avoiding irrelevant results) - threshold tuning must prioritize avoiding false positives while maintaining good recall
    SpecificSearchResultRequirement: NexusAssistant.searchSpecifications must return specific fragments that precisely match the query intent, providing the exact statement, action, property, or rule that answers the question along with parent entity and referenced entity context for complete understanding
    HybridTraceDiscovery: IntelligentTraceEngine must automatically discover connections between specifications and code without manual tagging by combining embedding-based similarity with LLM reasoning - neither approach alone is sufficient for accurate traceability that users can trust
    ExplainableTraceLinks: Every discovered trace link must include a human-readable explanation of why the connection exists, generated by IntelligentTraceEngine, so developers understand rationale behind traceability
    ConfidenceTransparency: IntelligentTraceEngine must provide confidence scores for all trace links so users understand reliability and can focus review on uncertain traces
    ContextualTraceValidation: LLM reasoning must consider full context including entity purposes, relationships, code behavior, and system architecture - not just isolated similarity scores - when validating trace links
    MultiHopTraceReasoning: IntelligentTraceEngine must be capable of following chains of relationships across layers to discover indirect trace links that direct similarity matching cannot find
    TraceAmbiguityResolution: When multiple specifications appear similar to code, IntelligentTraceEngine must use LLM reasoning to disambiguate and identify the correct connection with detailed explanation of why other candidates were rejected

entity: ProductManager
role: actor
purpose:
    - Defines product requirements and creates new features in ProductView
    - Manages the product vision and user-facing capabilities
    - Needs support to ensure specifications are complete and aligned with existing system
actions:
    defineRequirements: Creates and maintains product view for new and existing features
    createFeature: Specifies new features and user capabilities in product views
    queryExistingFeatures: Asks assistant about existing product capabilities and implementations
    exploreSystem: Discovers and explores entities to understand existing system structure and capabilities
relations:
    @NexusAssistant: uses assistant service to query existing features and validate new requirements
    @ProductView: creates and maintains product specifications in this view

entity: Developer
role: actor
purpose: 
    - Software engineer who designs system architecture and implements features
    - Creates and maintains SystemDesignView to support product needs
    - Requires clear, actionable guidance on how to translate product requirements into system design and code
actions:
    queryAssistant: Asks assistant for system design or implementation guidance on specific features or questions
    designSystem: Creates and maintains system design view to support product requirements
    implementFeature: Writes code to implement features based on specifications and guidance received
    exploreSystem: Discovers and explores entities across layers to understand system architecture and dependencies
relations:
    @NexusAssistant: uses assistant service to get implementation guidance and trace requirements to code
    @SystemDesignView: creates and maintains design specifications in this view

entity: AIAgent
role: actor
purpose:
    - Autonomous assistant that helps manage product requirements, system design, and code implementation
    - Works across all three layers: product, design, and implementation
    - Needs precise context and constraints to generate appropriate artifacts
actions:
    manageProductRequirements: Creates and maintains product view based on user needs and business requirements
    manageSystemDesign: Creates and maintains system design view to support product requirements
    requestContext: Requests implementation context from assistant for a specific feature
    generateCode: Creates code that meets product and architectural requirements based on provided context
    exploreSystem: Discovers and explores entities to understand system structure before generating specifications or code
relations:
    @NexusAssistant: uses assistant service to get guidance and context across all layers
    @ProductView: creates and maintains product specifications in this view
    @SystemDesignView: creates and maintains design specifications in this view
    @ImplementationContext: requests implementation context from NexusAssistant for specific features

entity: ImplementationContext
role: component
purpose:
    - Synthesized guidance that combines product requirements with architectural decisions
    - Provides specific, actionable implementation instructions
    - Generated by NexusAssistant for Developer and AIAgent consumption

relations:
    @NexusAssistant: receives synthesized implementation context from assistant
    @Developer: provides implementation guidance to developers
    @AIAgent: provides implementation guidance to AI agents

entity: ProductView
role: component
purpose:
    - Represents the user-facing features and business capabilities
    - Describes WHAT the system does from customer and business perspective
    - Contains user journeys, business rules, and value propositions
    - Written in Nexus language focusing on WHY features exist
relations:
    @SystemDesignView: provides product requirements that are realized by design specifications in system design view

entity: SystemDesignView
role: component
purpose:
    - Represents the technical architecture and system structure
    - Describes HOW the system is organized at high level
    - Contains modules, services, data flows, data struct, schemas, and integration patterns
    - Written in Nexus language focusing on architectural decisions and patterns
relations:
    @ComponentImplementation: provides architectural design that is realized by component implementations

entity: ComponentImplementation
role: component
purpose:
    - Represents specific code-level components and their implementation details
    - Describes the actual technical implementation of features
    - Contains APIs, data structures, algorithms, and technical constraints
    - Written in Nexus language focusing on concrete implementation requirements

entity: IntelligentTraceEngine
role: service
purpose:
    - Combines embedding-based similarity with LLM reasoning to discover accurate trace links between specification fragments and code fragments
    - Creates fine-grained embeddings for each statement, action, property, and code method enabling precise matching
    - Validates and explains connections using contextual understanding beyond simple similarity matching
    - Reasons about indirect relationships that embeddings alone cannot capture
    - Generates human-readable explanations for why trace links exist between specific fragments
    - Resolves ambiguities when multiple fragments appear similar
    - Persists discovered trace links to disk avoiding expensive re-discovery on restart when nothing has changed
    - Detects when any specification or code fragment changes and triggers targeted re-discovery while reusing unchanged fragment embeddings
    - Enriches fragment understanding with parent entity context and referenced entities before comparing them for better trace discovery
actions:
    discoverTraces: Uses embedding analyzer to find candidate matches, then LLM reasoner to validate and discover additional connections
    validateTraceLink: Applies LLM reasoner to confirm if a candidate trace link is valid given full specification and code context
    explainConnection: Generates natural language explanation of why a specification connects to specific code
    reasonAboutIndirectLinks: Follows chains of relationships that embeddings miss
    disambiguateMatches: Applies contextual reasoning when multiple similar entities exist to identify correct connections
    assessTraceConfidence: Scores trace link quality using both semantic similarity and logical reasoning
    enrichContext: Gathers complete understanding of entities including their relationships and architectural role before matching
relations:
    @SemanticMatcher: receives candidate trace links from semantic matcher for validation
    @LLMReasoner: sends candidates to reasoner for validation and indirect connection discovery
    @TraceValidation: sends trace links to validator for confidence scoring and quality assessment
    @ExplanationGenerator: sends validated trace links to generator for human-readable justifications
    @ContextEnricher: receives enriched fragment context from enricher for accurate matching

entity: SemanticMatcher
role: component
purpose:
    - Provides fast embedding-based similarity matching at fragment level as first stage of trace discovery
    - Compares individual statement and code method embeddings for precise matching
    - Generates candidate trace links between specific fragments for IntelligentTraceEngine validation

relations:
    @IntelligentTraceEngine: provides candidate trace links to engine for validation

entity: LLMReasoner
role: component
purpose:
    - Applies large language model reasoning to validate trace links and discover non-obvious connections
    - Understands context, intent, and logical relationships beyond embedding similarity

entity: TraceValidation
role: component
purpose:
    - Scores trace link confidence based on multiple quality signals
    - Identifies high-confidence traces and flags uncertain connections for review

entity: ExplanationGenerator
role: component
purpose:
    - Creates human-readable justifications explaining why trace links exist
    - Helps developers understand traceability rationale, not just see connections

entity: ContextEnricher
role: component
purpose:
    - Provides complete understanding of each fragment before comparing them for trace discovery
    - Gathers parent entity context and all referenced entities showing their architectural role
    - Explains what each layer represents so connections make sense to developers and product managers
    - Includes related entities that provide context about why a fragment exists and how it fits in the broader system
    - Ensures trace discovery understands the complete picture rather than isolated statement text
    - Reduces false connections by helping identify when fragments serve different purposes despite similar wording
    - Improves accuracy of discovered traces by providing rich context that reveals true semantic relationships

entity: MCPServerInterface
role: service
purpose:
    - Exposes NexusAssistant capabilities to external AI agents and tools via Model Context Protocol
    - Enables third-party AI systems to query product specifications and system designs
    - Provides standardized protocol interface for both internal and external agent integration
    - Allows external tools to request implementation context and navigate specification layers
actions:
    serveMCPRequest: Handles incoming MCP protocol requests from external AI agents
    exposeContext: Provides implementation context through MCP interface
    exposeNavigation: Enables specification layer navigation for external clients
relations:
    @NexusAssistant: exposes subset of NexusAssistant capabilities through MCP protocol
    @ImplementationContext: provides implementation context to external clients through MCP interface

entity: WebInterface
role: component
purpose:
    - Simple multi-tab browser interface wrapping all REST API endpoints
    - Enables users to explore specifications, search semantically, and view traceability without coding or API knowledge
    - Provides visual access to graph visualization, entity browsing, semantic search, trace links, and code entities
    - Stupid simple HTML design - just forms and displays around JSON APIs with no complex frameworks
actions:
    showGraphVisualization: Displays interactive network graph of entities and relations with filtering by layer and catalog
    showSemanticSearch: Provides search input and displays fragment results with parent entity context and confidence scores
    showEntitiesBrowser: Lists specification entities with filtering by layer, catalog, and role
    showTraceLinksBrowser: Displays discovered trace links with confidence scores, rationales, and validation status
    showCodeEntitiesBrowser: Lists parsed code entities with file paths, signatures, and docstrings
    showEntityDetails: Shows complete entity information including purposes, actions, properties, relations, and rules
    navigateBetweenViews: Enables seamless navigation between tabs following entity relationships and trace links
relations:
    @NexusAssistant: provides web-based access to all NexusAssistant capabilities for users

scenario: DeveloperSeeksImplementationGuidance
Given a developer working on a new feature
When they query the @NexusAssistant with a specific implementation question
Then the assistant analyzes both @ProductView and @SystemDesignView
And shows existing code that implements similar features
And provides contextual implementation guidance 
And includes specific code patterns, constraints, and business logic requirements

scenario: AIAgentGeneratesCode
Given an @AIAgent tasked with implementing a feature
When it requests implementation context from @NexusAssistant
Then the assistant provides structured guidance including:
    - Business rules that must be enforced
    - Technical patterns to follow
    - Integration requirements with existing components
    - Validation and error handling requirements
And the AI agent can generate code that meets both product and architectural requirements

scenario: SpecificationAlignment
Given @ProductView and @SystemDesignView that may have gaps or conflicts
When @NexusAssistant analyzes them
Then it identifies missing implementation details
And highlights potential conflicts between product and design views
And suggests clarifications needed before implementation can proceed

scenario: MultiLayerNavigation
Given a developer or AI agent needs to understand a feature
When they query @NexusAssistant about the feature
Then the assistant provides context across all three layers in sequence:
    - @ProductView: WHY the feature exists and WHAT it does for users
    - @SystemDesignView: HOW the product requirements are translated into technical architecture
    - @ComponentImplementation: Specific technical details and code-level requirements that realize the design
And enables navigation between layers following the product → design → implementation flow


scenario: FindWhyCodeExists
Given a developer looking at unfamiliar code
When they ask @NexusAssistant why this code exists
Then the assistant traces backward from code through @SystemDesignView to @ProductView
And shows the design decisions that translated requirements into this implementation
And reveals the product requirements that justify this code
And explains the business value delivered by this code

scenario: IdentifyImplementationGaps
Given @ProductManager reviewing product roadmap
When they query @NexusAssistant about feature status
Then the assistant shows which requirements are fully implemented with high-confidence trace links
And highlights which requirements have no corresponding code yet
And flags low-confidence traces for human review
And helps prioritize implementation work based on gaps and trace quality

scenario: AssessChangeImpact
Given @Developer planning to modify code
When they query @NexusAssistant about potential impacts
Then the assistant identifies which requirements might be affected
And shows which other code depends on the changes
And warns about risks to product features

scenario: ExploratoryNaturalLanguageSearch
Given a developer or product manager unfamiliar with the system
When they ask "What components are responsible for parsing specifications?"
Then @NexusAssistant transforms the question into multiple declarative search phrases matching documentation style
And understands the semantic intent without requiring exact entity names
And searches specification fragments with each phrase variation, finding matches across different vocabulary
And returns specific action and purpose statements that describe parsing responsibilities
And includes parent entity information and referenced entities for complete context
And shows which search phrase variation matched each result for transparency
And explains how these fragments and their entities work together to accomplish parsing

scenario: SemanticLayerDiscovery
Given an @AIAgent exploring the system architecture
When it asks "How does the system expose functionality to AI agents?"
Then @NexusAssistant interprets the question semantically
And identifies design entities related to API exposure and agent integration
And returns components that handle external agent access and their relationships
And provides context about how these components enable integration

scenario: IntentBasedEntitySearch
Given a user asking about capabilities without knowing exact terminology
When they query "Find all entities in the design layer"
Then @NexusAssistant understands they want to browse entities by layer
And retrieves all design-layer entities from the knowledge graph
And presents them with their roles, purposes, and key relationships
And enables further exploration of discovered entities

scenario: FuzzyConceptMatching
Given a query with approximate or alternative terminology
When user asks "What handles file watching?"
Then @NexusAssistant generates multiple search phrases: "file watching handler", "monitors file changes", "file change detection"
And matches these concepts to related entities using semantic search across all phrase variations
And finds the component that monitors file changes through best-matching phrase
And explains the entity's purpose and file watching capability
And shows which specific phrase variation matched the result
And shows scenarios demonstrating the file watching behavior

scenario: DiscoverAllEntitiesInCatalog
Given a user exploring an unfamiliar catalog
When they request to see all entities in that catalog
Then @NexusAssistant lists all entities with their roles and brief purposes
And groups entities by layer (product, design, implementation) when relevant
And enables further exploration of any discovered entity

scenario: FilterEntitiesByContext
Given a developer working on a specific feature area
When they request entities related to a particular context (e.g., "authentication" or "payment processing")
Then @NexusAssistant discovers entities semantically related to that context
And shows entities across layers that participate in that domain
And explains how discovered entities connect to form the feature

scenario: ExploreEntityDetails
Given a user who discovered an entity name
When they request detailed information about that entity
Then @NexusAssistant provides the entity's complete definition including purpose, properties, actions
And shows relationships to other entities both incoming and outgoing
And identifies which layer the entity belongs to
And provides navigation to related entities for deeper exploration

scenario: BrowseByLayer
Given a user understanding the system's layered architecture
When they browse entities by layer (product, design, or implementation)
Then @NexusAssistant lists all entities in that layer across all catalogs
And helps users understand the system from a specific perspective
And enables cross-layer navigation to see how layers connect

scenario: DiscoverByRole
Given a user looking for specific types of entities
When they filter by role (actor, service, component, module, etc.)
Then @NexusAssistant discovers all entities with that role
And shows how entities of that role interact within the system
And provides context about each entity's responsibilities

scenario: AccurateContextualFragmentRetrieval
Given a developer asks "What entities are involved in processing payment transactions?"
When @NexusAssistant receives this complex contextual question
Then it generates multiple declarative search phrases: "entities process payment transactions", "payment transaction processing", "entities involved in payments"
And thoroughly analyzes each phrase to match against documentation vocabulary
And searches across both @ProductView and @SystemDesignView fragments with all phrase variations comprehensively to ensure no relevant statements are missed
And deeply understands individual statement semantics including purposes, properties, and actions to find accurate semantic matches
And verifies semantic similarity scores meet quality thresholds to avoid false positives
And identifies specific purpose and action statements in PaymentFlow, PaymentGateway, and related entities
And returns matched fragments with parent entity information and all referenced entities for complete context
And includes which search phrase variation matched each result for transparency
And ranks results by relevance showing most contextually appropriate fragments first with confidence scores
And returns complete, accurate results optimized for speed where possible without compromising correctness

scenario: DeepSemanticUnderstanding
Given a product manager asks "Which features help users recover from errors?"
When @NexusAssistant processes this question
Then it generates search phrases: "features help users recover from errors", "error recovery features", "users recover from errors", "error handling for users"
And understands "recover from errors" semantically across all phrase variations (not just text matching)
And analyzes purpose statement fragments with each phrase to find those describing error handling, validation, recovery flows
And examines action statement fragments with each phrase to identify retry, rollback, or recovery operations
And considers referenced entities in each fragment to find connected error management capabilities
And returns specific matching statement fragments from multiple layers showing complete error recovery ecosystem
And includes parent entity context and all referenced entities for each matched fragment
And shows which phrase variation produced each match
And explains how each fragment contributes to error recovery

scenario: CrossLayerContextualSearch
Given an @AIAgent asks "What defines and implements user authentication?"
When @NexusAssistant interprets this question
Then it recognizes the question spans both product definition and design implementation
And searches @ProductView for authentication features and user flows
And simultaneously searches @SystemDesignView for authentication components and services
And understands the connections between product requirements and design implementations
And returns unified results showing authentication entities from both layers
And highlights the traceability between product features and technical components
And enables navigation from "what" to "how" seamlessly

scenario: IntelligentEntityRanking
Given multiple entities match a search query
When @NexusAssistant ranks the results
Then it considers semantic similarity to the question
And weights entities with richer purposes and more detailed actions higher
And prioritizes entities with more relationships as they're more central to system
And places entities from the question's target layer (if specified) at the top
And includes related entities that might be indirectly relevant
And presents ranked results with relevance scores explaining why each entity matched

scenario: FastIterativeRefinement
Given a user performs multiple related searches in sequence
When @NexusAssistant handles these queries
Then it maintains context between searches to understand evolving intent
And caches semantic analysis to enable sub-second response times
And learns from which results the user explores to improve relevance
And suggests related entities based on exploration patterns
And enables rapid, fluid discovery through intelligent suggestions

scenario: LLMEnhancedTraceDiscovery
Given @NexusAssistant analyzing specifications and codebase for trace links
When embeddings identify candidate connections
Then @IntelligentTraceEngine applies LLM reasoning to validate each candidate
And filters out false positives by understanding full context of specifications and code
And discovers additional connections through multi-hop reasoning that embeddings missed
And assigns confidence scores based on both semantic similarity and logical validation
And provides explanations for each discovered trace link
And ensures high-quality traceability that users can trust

scenario: ExplainWhyCodeImplementsSpec
Given a developer viewing a trace link between specification and code
When they ask why this connection exists
Then @IntelligentTraceEngine analyzes the specification's purpose, properties, and actions
And examines the code's structure, logic, and naming
And generates natural language explanation describing:
    - Which specification requirements the code fulfills
    - How the code's behavior aligns with specification intent
    - Why this connection makes logical sense
    - Confidence level in this trace link
And helps developers understand traceability rationale, not just see connections

scenario: DiscoverIndirectTraceLinks
Given a product requirement that doesn't directly mention implementation details
When embedding-based search finds no obvious code matches
Then @IntelligentTraceEngine uses LLM to reason through the design layer
And identifies which design entities realize the product requirement
And traces from those design entities to actual implementing code
And builds multi-hop trace paths: requirement → design → implementation
And reveals connections that pure similarity matching cannot find
And shows complete traceability even when direct similarity is low

scenario: ResolveTraceAmbiguity
Given multiple specification entities with similar embeddings to a code component
When @IntelligentTraceEngine needs to determine the correct connection
Then it uses LLM reasoning to understand contextual differences between candidates
And examines the code's actual logic flow and behavior deeply
And compares against each candidate specification's requirements
And identifies which specification truly describes this code's intent
And explains precisely why this match is correct and why other candidates were rejected
And provides confidence score for the decision
And prevents false trace links that would mislead developers

scenario: ContextAwareTraceDiscovery
Given a product requirement describing user authentication flow
When the requirement uses business terminology with minimal technical implementation details
And direct text similarity to authentication code is low
Then @IntelligentTraceEngine uses @ContextEnricher to gather complete understanding of the requirement
And @ContextEnricher identifies related entities showing this requirement connects to security and user management
And @ContextEnricher explains what the product layer represents: business value and user-facing capabilities
And @ContextEnricher explains what the code layer represents: actual technical implementation
And @IntelligentTraceEngine uses this enriched context to understand the requirement's true purpose and scope
And discovers the correct connection to authentication code because enriched context reveals the semantic relationship
And provides clear explanation to developers showing why the connection makes sense despite different terminology
And developers trust the discovered trace because the rationale explains the business-to-technical mapping
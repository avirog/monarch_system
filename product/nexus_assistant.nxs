
catalog: NexusAssistant

entity: NexusAssistant
role: service
purpose:
    - Bridges the gap between product specifications and implementation by providing contextual guidance
    - Rapidly finds and retrieves relevant specification fragments from any layer using deep semantic understanding of questions
    - Precisely matches queries to specific statements, actions, properties, and rules rather than entire entities for accurate results
    - Returns exact matching content with full context including parent entity and all referenced entities
    - Deeply understands individual statement semantics and relationships to answer contextual queries with precision
    - Enables product managers to manage requirements and create new features effectively
    - Enables developers to manage system design that supports product needs and to implement features
    - Enables AI agents to understand exact implementation requirements from product and architectural designs
    - Automatically discovers which code fragments implement which specification fragments using AI analysis
    - Shows developers and product managers how specific requirements connect to actual implementation code
    - Reduces miscommunication between product vision, system design and technical execution

properties:
    productView: @ProductView, collection of product-level views managed by the assistant
    systemDesignView: @SystemDesignView, collection of system design views managed by the assistant
    componentImplementations: @ComponentImplementation, collection of component-level implementations managed by the assistant
    traceEngine: @IntelligentTraceEngine, intelligent traceability engine combining embeddings and LLM reasoning
    mcpInterface: @MCPServerInterface, protocol interface for external AI agent access

actions:
    provideImplementationContext: Generates @ImplementationContext on-demand by synthesizing product requirements and architectural decisions for specific implementation needs
    analyzeSpecifications: Examines @ProductView and @SystemDesignView to identify gaps, conflicts, or missing details
    traceRequirement: Uses @IntelligentTraceEngine to trace requirements bidirectionally - from @ProductView through @SystemDesignView to code, or backward from code to product value
    identifyRelatedEntities: Determines which entities may be affected by changes or are important in a given context
    assessCoverage: Reports which requirements have been implemented, validates trace quality with confidence scores, and highlights gaps needing review
    manageRequirements: Helps organize, track, and maintain @ProductView for product managers
    manageSystemDesign: Helps organize, track, and maintain @SystemDesignView for developers
    validateFeatureReadiness: Checks if new feature specifications are complete and ready for design and implementation
    searchSpecifications: Semantically finds relevant specification fragments from any layer by deeply understanding question intent and matching against individual statements, returning precise results with parent entity context and referenced entities
    discoverEntities: Lists and explores entities across catalogs, filtered by layer, role, catalog, or context
    exploreEntity: Provides detailed information about a specific entity including its purpose, properties, actions, and relationships
    browseEntityGraph: Enables navigation through the entity relationship graph to understand system structure and dependencies
    explainTraceRationale: Provides detailed explanation of why a trace link exists using @IntelligentTraceEngine to generate human-readable justifications
    resolveAmbiguousTraces: Uses @IntelligentTraceEngine LLM reasoning to clarify which specification truly connects to which code when similarity alone is insufficient

entity: ProductManager
role: actor
purpose:
    - Defines product requirements and creates new features in @ProductView
    - Manages the product vision and user-facing capabilities
    - Needs support to ensure specifications are complete and aligned with existing system

properties:
    assistant: @NexusAssistant, the assistant service used for requirements management

actions:
    defineRequirements: Creates and maintains @ProductView for new and existing features
    createFeature: Specifies new features and user capabilities in product views
    queryExistingFeatures: Asks @NexusAssistant about existing product capabilities and implementations
    exploreSystem: Discovers and explores entities to understand existing system structure and capabilities

entity: Developer
role: actor
purpose: 
    - Software engineer who designs system architecture and implements features
    - Creates and maintains @SystemDesignView to support product needs
    - Requires clear, actionable guidance on how to translate product requirements into system design and code

properties:
    assistant: @NexusAssistant, the assistant service used for system design and implementation guidance

actions:
    queryAssistant: Asks @NexusAssistant for system design or implementation guidance on specific features or questions
    designSystem: Creates and maintains @SystemDesignView to support product requirements
    implementFeature: Writes code to implement features based on specifications and guidance received
    exploreSystem: Discovers and explores entities across layers to understand system architecture and dependencies

entity: AIAgent
role: actor
purpose:
    - Autonomous assistant that helps manage product requirements, system design, and code implementation
    - Works across all three layers: product, design, and implementation
    - Needs precise context and constraints to generate appropriate artifacts

properties:
    assistant: @NexusAssistant, the assistant service used for product, design, and implementation guidance

actions:
    manageProductRequirements: Creates and maintains @ProductView based on user needs and business requirements
    manageSystemDesign: Creates and maintains @SystemDesignView to support product requirements
    requestContext: Requests @ImplementationContext from @NexusAssistant for a specific feature
    generateCode: Creates code that meets product and architectural requirements based on provided context
    exploreSystem: Discovers and explores entities to understand system structure before generating specifications or code

entity: ImplementationContext
role: component
purpose:
    - Synthesized guidance that combines product requirements with architectural decisions
    - Provides specific, actionable implementation instructions
    - Generated by @NexusAssistant for @Developer and @AIAgent consumption

entity: ProductView
role: component
purpose:
    - Represents the user-facing features and business capabilities
    - Describes WHAT the system does from customer and business perspective
    - Contains user journeys, business rules, and value propositions
    - Written in Nexus language focusing on WHY features exist

properties:
    systemDesigns: @SystemDesignView, collection of system designs that realize this product

entity: SystemDesignView
role: component
purpose:
    - Represents the technical architecture and system structure
    - Describes HOW the system is organized at high level
    - Contains modules, services, data flows, data struct, schemas, and integration patterns
    - Written in Nexus language focusing on architectural decisions and patterns

properties:
    componentImplementations: @ComponentImplementation, collection of component implementations that realize this design

entity: ComponentImplementation
role: component
purpose:
    - Represents specific code-level components and their implementation details
    - Describes the actual technical implementation of features
    - Contains APIs, data structures, algorithms, and technical constraints
    - Written in Nexus language focusing on concrete implementation requirements

entity: IntelligentTraceEngine
role: service
purpose:
    - Combines embedding-based similarity with LLM reasoning to discover accurate trace links between specification fragments and code fragments
    - Creates fine-grained embeddings for each statement, action, property, and code method enabling precise matching
    - Validates and explains connections using contextual understanding beyond simple similarity matching
    - Reasons about indirect relationships that embeddings alone cannot capture
    - Generates human-readable explanations for why trace links exist between specific fragments
    - Resolves ambiguities when multiple fragments appear similar
    - Continuously learns and refines trace quality based on validation feedback
    - Persists discovered trace links to disk avoiding expensive re-discovery on restart when nothing has changed
    - Detects when any specification or code fragment changes and triggers targeted re-discovery while reusing unchanged fragment embeddings
    - Enriches fragment understanding with parent entity context and referenced entities before comparing them for better trace discovery

properties:
    embeddingAnalyzer: @SemanticMatcher, provides initial similarity-based candidate matches
    llmReasoner: @LLMReasoner, validates candidates and discovers non-obvious connections
    traceValidation: @TraceValidation, confidence scoring and quality assessment
    explanationGenerator: @ExplanationGenerator, creates human-readable justifications for trace links
    contextEnricher: @ContextEnricher, gathers complete entity context for accurate understanding

actions:
    discoverTraces: Uses @embeddingAnalyzer to find candidate matches, then @llmReasoner to validate and discover additional connections
    validateTraceLink: Applies @llmReasoner to confirm if a candidate trace link is valid given full specification and code context
    explainConnection: Generates natural language explanation of why a specification connects to specific code
    reasonAboutIndirectLinks: Uses @llmReasoner to follow chains of relationships that embeddings miss
    disambiguateMatches: Applies contextual reasoning when multiple similar entities exist to identify correct connections
    assessTraceConfidence: Scores trace link quality using both semantic similarity and logical reasoning
    refineTraceQuality: Learns from user feedback to improve future trace discovery accuracy
    enrichContext: Uses @ContextEnricher to gather complete understanding of entities including their relationships and architectural role before matching

entity: SemanticMatcher
role: component
purpose:
    - Provides fast embedding-based similarity matching at fragment level as first stage of trace discovery
    - Compares individual statement and code method embeddings for precise matching
    - Generates candidate trace links between specific fragments for @IntelligentTraceEngine validation

entity: LLMReasoner
role: component
purpose:
    - Applies large language model reasoning to validate trace links and discover non-obvious connections
    - Understands context, intent, and logical relationships beyond embedding similarity

entity: TraceValidation
role: component
purpose:
    - Scores trace link confidence based on multiple quality signals
    - Identifies high-confidence traces and flags uncertain connections for review

entity: ExplanationGenerator
role: component
purpose:
    - Creates human-readable justifications explaining why trace links exist
    - Helps developers understand traceability rationale, not just see connections

entity: ContextEnricher
role: component
purpose:
    - Provides complete understanding of each fragment before comparing them for trace discovery
    - Gathers parent entity context and all referenced entities showing their architectural role
    - Explains what each layer represents so connections make sense to developers and product managers
    - Includes related entities that provide context about why a fragment exists and how it fits in the broader system
    - Ensures trace discovery understands the complete picture rather than isolated statement text
    - Reduces false connections by helping identify when fragments serve different purposes despite similar wording
    - Improves accuracy of discovered traces by providing rich context that reveals true semantic relationships

entity: MCPServerInterface
role: service
purpose:
    - Exposes @NexusAssistant capabilities to external AI agents and tools via Model Context Protocol
    - Enables third-party AI systems to query product specifications and system designs
    - Provides standardized protocol interface for both internal and external agent integration
    - Allows external tools to request @ImplementationContext and navigate specification layers

properties:
    exposedOperations: @NexusAssistant, subset of @NexusAssistant actions available through MCP protocol

actions:
    serveMCPRequest: Handles incoming MCP protocol requests from external AI agents
    exposeContext: Provides @ImplementationContext through MCP interface
    exposeNavigation: Enables specification layer navigation for external clients

scenario: DeveloperSeeksImplementationGuidance
Given a developer working on a new feature
When they query the @NexusAssistant with a specific implementation question
Then the assistant analyzes both @ProductView and @SystemDesignView
And shows existing code that implements similar features
And provides contextual implementation guidance 
And includes specific code patterns, constraints, and business logic requirements

scenario: AIAgentGeneratesCode
Given an @AIAgent tasked with implementing a feature
When it requests implementation context from @NexusAssistant
Then the assistant provides structured guidance including:
    - Business rules that must be enforced
    - Technical patterns to follow
    - Integration requirements with existing components
    - Validation and error handling requirements
And the AI agent can generate code that meets both product and architectural requirements

scenario: SpecificationAlignment
Given @ProductView and @SystemDesignView that may have gaps or conflicts
When @NexusAssistant analyzes them
Then it identifies missing implementation details
And highlights potential conflicts between product and design views
And suggests clarifications needed before implementation can proceed

scenario: MultiLayerNavigation
Given a developer or AI agent needs to understand a feature
When they query @NexusAssistant about the feature
Then the assistant provides context across all three layers in sequence:
    - @ProductView: WHY the feature exists and WHAT it does for users
    - @SystemDesignView: HOW the product requirements are translated into technical architecture
    - @ComponentImplementation: Specific technical details and code-level requirements that realize the design
And enables navigation between layers following the product → design → implementation flow


scenario: FindWhyCodeExists
Given a developer looking at unfamiliar code
When they ask @NexusAssistant why this code exists
Then the assistant traces backward from code through @SystemDesignView to @ProductView
And shows the design decisions that translated requirements into this implementation
And reveals the product requirements that justify this code
And explains the business value delivered by this code

scenario: IdentifyImplementationGaps
Given @ProductManager reviewing product roadmap
When they query @NexusAssistant about feature status
Then the assistant shows which requirements are fully implemented with high-confidence trace links
And highlights which requirements have no corresponding code yet
And flags low-confidence traces for human review
And helps prioritize implementation work based on gaps and trace quality

scenario: AssessChangeImpact
Given @Developer planning to modify code
When they query @NexusAssistant about potential impacts
Then the assistant identifies which requirements might be affected
And shows which other code depends on the changes
And warns about risks to product features

scenario: ExploratoryNaturalLanguageSearch
Given a developer or product manager unfamiliar with the system
When they ask "What components are responsible for parsing specifications?"
Then @NexusAssistant understands the semantic intent without requiring exact entity names
And searches specification fragments using meaning and context, not exact text matching
And returns specific action and purpose statements that describe parsing responsibilities
And includes parent entity information and referenced entities for complete context
And explains how these fragments and their entities work together to accomplish parsing

scenario: SemanticLayerDiscovery
Given an @AIAgent exploring the system architecture
When it asks "How does the system expose functionality to AI agents?"
Then @NexusAssistant interprets the question semantically
And identifies design entities related to API exposure and agent integration
And returns components that handle external agent access and their relationships
And provides context about how these components enable integration

scenario: IntentBasedEntitySearch
Given a user asking about capabilities without knowing exact terminology
When they query "Find all entities in the design layer"
Then @NexusAssistant understands they want to browse entities by layer
And retrieves all design-layer entities from the knowledge graph
And presents them with their roles, purposes, and key relationships
And enables further exploration of discovered entities

scenario: FuzzyConceptMatching
Given a query with approximate or alternative terminology
When user asks "What handles file watching?"
Then @NexusAssistant matches concepts like "file watching" to related entities
And finds the component that monitors file changes
And explains the entity's purpose and file watching capability
And shows scenarios demonstrating the file watching behavior

scenario: DiscoverAllEntitiesInCatalog
Given a user exploring an unfamiliar catalog
When they request to see all entities in that catalog
Then @NexusAssistant lists all entities with their roles and brief purposes
And groups entities by layer (product, design, implementation) when relevant
And enables further exploration of any discovered entity

scenario: FilterEntitiesByContext
Given a developer working on a specific feature area
When they request entities related to a particular context (e.g., "authentication" or "payment processing")
Then @NexusAssistant discovers entities semantically related to that context
And shows entities across layers that participate in that domain
And explains how discovered entities connect to form the feature

scenario: ExploreEntityDetails
Given a user who discovered an entity name
When they request detailed information about that entity
Then @NexusAssistant provides the entity's complete definition including purpose, properties, actions
And shows relationships to other entities both incoming and outgoing
And identifies which layer the entity belongs to
And provides navigation to related entities for deeper exploration

scenario: BrowseByLayer
Given a user understanding the system's layered architecture
When they browse entities by layer (product, design, or implementation)
Then @NexusAssistant lists all entities in that layer across all catalogs
And helps users understand the system from a specific perspective
And enables cross-layer navigation to see how layers connect

scenario: DiscoverByRole
Given a user looking for specific types of entities
When they filter by role (actor, service, component, module, etc.)
Then @NexusAssistant discovers all entities with that role
And shows how entities of that role interact within the system
And provides context about each entity's responsibilities

scenario: AccurateContextualFragmentRetrieval
Given a developer asks "What entities are involved in processing payment transactions?"
When @NexusAssistant receives this complex contextual question
Then it thoroughly analyzes the question to extract key concepts: "payment", "transactions", "processing"
And searches across both @ProductView and @SystemDesignView fragments comprehensively to ensure no relevant statements are missed
And deeply understands individual statement semantics including purposes, properties, and actions to find accurate semantic matches
And verifies semantic similarity scores meet quality thresholds to avoid false positives
And identifies specific purpose and action statements in PaymentFlow, PaymentGateway, and related entities
And returns matched fragments with parent entity information and all referenced entities for complete context
And ranks results by relevance showing most contextually appropriate fragments first with confidence scores
And returns complete, accurate results optimized for speed where possible without compromising correctness

scenario: DeepSemanticUnderstanding
Given a product manager asks "Which features help users recover from errors?"
When @NexusAssistant processes this question
Then it understands "recover from errors" semantically (not just text matching)
And analyzes purpose statement fragments to find those describing error handling, validation, recovery flows
And examines action statement fragments to identify retry, rollback, or recovery operations
And considers referenced entities in each fragment to find connected error management capabilities
And returns specific matching statement fragments from multiple layers showing complete error recovery ecosystem
And includes parent entity context and all referenced entities for each matched fragment
And explains how each fragment contributes to error recovery

scenario: CrossLayerContextualSearch
Given an @AIAgent asks "What defines and implements user authentication?"
When @NexusAssistant interprets this question
Then it recognizes the question spans both product definition and design implementation
And searches @ProductView for authentication features and user flows
And simultaneously searches @SystemDesignView for authentication components and services
And understands the connections between product requirements and design implementations
And returns unified results showing authentication entities from both layers
And highlights the traceability between product features and technical components
And enables navigation from "what" to "how" seamlessly

scenario: IntelligentEntityRanking
Given multiple entities match a search query
When @NexusAssistant ranks the results
Then it considers semantic similarity to the question
And weights entities with richer purposes and more detailed actions higher
And prioritizes entities with more relationships as they're more central to system
And places entities from the question's target layer (if specified) at the top
And includes related entities that might be indirectly relevant
And presents ranked results with relevance scores explaining why each entity matched

scenario: FastIterativeRefinement
Given a user performs multiple related searches in sequence
When @NexusAssistant handles these queries
Then it maintains context between searches to understand evolving intent
And caches semantic analysis to enable sub-second response times
And learns from which results the user explores to improve relevance
And suggests related entities based on exploration patterns
And enables rapid, fluid discovery through intelligent suggestions

scenario: LLMEnhancedTraceDiscovery
Given @NexusAssistant analyzing specifications and codebase for trace links
When embeddings identify candidate connections
Then @IntelligentTraceEngine applies LLM reasoning to validate each candidate
And filters out false positives by understanding full context of specifications and code
And discovers additional connections through multi-hop reasoning that embeddings missed
And assigns confidence scores based on both semantic similarity and logical validation
And provides explanations for each discovered trace link
And ensures high-quality traceability that users can trust

scenario: ExplainWhyCodeImplementsSpec
Given a developer viewing a trace link between specification and code
When they ask why this connection exists
Then @IntelligentTraceEngine analyzes the specification's purpose, properties, and actions
And examines the code's structure, logic, and naming
And generates natural language explanation describing:
    - Which specification requirements the code fulfills
    - How the code's behavior aligns with specification intent
    - Why this connection makes logical sense
    - Confidence level in this trace link
And helps developers understand traceability rationale, not just see connections

scenario: DiscoverIndirectTraceLinks
Given a product requirement that doesn't directly mention implementation details
When embedding-based search finds no obvious code matches
Then @IntelligentTraceEngine uses LLM to reason through the design layer
And identifies which design entities realize the product requirement
And traces from those design entities to actual implementing code
And builds multi-hop trace paths: requirement → design → implementation
And reveals connections that pure similarity matching cannot find
And shows complete traceability even when direct similarity is low

scenario: ResolveTraceAmbiguity
Given multiple specification entities with similar embeddings to a code component
When @IntelligentTraceEngine needs to determine the correct connection
Then it uses LLM reasoning to understand contextual differences between candidates
And examines the code's actual logic flow and behavior deeply
And compares against each candidate specification's requirements
And identifies which specification truly describes this code's intent
And explains precisely why this match is correct and why other candidates were rejected
And provides confidence score for the decision
And prevents false trace links that would mislead developers

scenario: LearnFromTraceFeedback
Given users validate, correct, or reject discovered trace links
When @IntelligentTraceEngine receives this feedback
Then it uses LLM to understand why the trace was correct or incorrect
And updates its reasoning patterns to improve future discovery
And refines confidence scoring based on what makes good traces
And continuously improves trace quality without manual retraining
And adapts to project-specific patterns and conventions

scenario: ContextAwareTraceDiscovery
Given a product requirement describing user authentication flow
When the requirement uses business terminology with minimal technical implementation details
And direct text similarity to authentication code is low
Then @IntelligentTraceEngine uses @ContextEnricher to gather complete understanding of the requirement
And @ContextEnricher identifies related entities showing this requirement connects to security and user management
And @ContextEnricher explains what the product layer represents: business value and user-facing capabilities
And @ContextEnricher explains what the code layer represents: actual technical implementation
And @IntelligentTraceEngine uses this enriched context to understand the requirement's true purpose and scope
And discovers the correct connection to authentication code because enriched context reveals the semantic relationship
And provides clear explanation to developers showing why the connection makes sense despite different terminology
And developers trust the discovered trace because the rationale explains the business-to-technical mapping

rule: ContextualAccuracy
@NexusAssistant must only provide implementation guidance that is consistent with both product requirements and architectural constraints

rule: TraceabilityRequirement
Every implementation recommendation must be traceable back to specific product requirements or architectural decisions

rule: RealTimeAnalysis
@NexusAssistant must analyze specifications in real-time and provide up-to-date guidance based on the latest versions

rule: MultiPerspectiveIntegration
Implementation context must synthesize both product manager perspective (WHAT/WHY) and architect perspective (HOW) into actionable developer guidance

rule: ThreeLayerConsistency
Information must remain consistent across @ProductView, @SystemDesignView, and @ComponentImplementation layers

rule: LayeredTraceability
Product requirements connect to code through design specifications, never directly - every @ProductView requirement traces through corresponding @SystemDesignView elements to reach @ComponentImplementation and actual code

rule: BidirectionalTraceability
The assistant must support tracing both top-down (from product requirements through design to actual code) and bottom-up (from code through design to product value and business justification)

rule: CoverageVisibility
Product managers and developers must be able to see which requirements have been implemented and which have gaps

rule: RelationalImpactAnalysis
When code or specifications change, @NexusAssistant must identify and communicate all related entities that may be affected or whose relationships are important to consider in any context, including implementation, design decisions, product changes, or understanding existing features

rule: SemanticSearchCapability
@NexusAssistant must support natural language queries that don't require exact entity names - searches must understand user intent, match concepts semantically, and return relevant results based on meaning rather than text matching alone

rule: EntityDiscoverability
Users must be able to discover entities without prior knowledge of entity names - @NexusAssistant must provide browsing, filtering, and exploration capabilities by catalog, layer, role, and context to enable understanding of the monitored system

rule: AccuracyAndCompleteness
@NexusAssistant must prioritize accuracy, precision, and completeness over response speed - returning all correct, relevant entities is more important than fast responses - but speed should be optimized where it doesn't compromise quality

rule: DeepFragmentUnderstanding
@NexusAssistant must analyze and understand the complete semantic meaning of each specification fragment including its statement text, parent entity context, and all referenced entities - enabling precise matching at statement level rather than coarse entity-level matching

rule: CrossLayerSearch
@NexusAssistant must seamlessly search across @ProductView, @SystemDesignView, and @ComponentImplementation layers simultaneously when questions span multiple perspectives, returning unified results that show connections between layers

rule: IntelligentRelevanceRanking
Search results must be ranked by contextual relevance considering semantic similarity, entity richness, relationship centrality, layer appropriateness, and indirect connections - most relevant entities must appear first with clear relevance explanations

rule: SemanticPrecision
@NexusAssistant must use appropriate similarity thresholds to balance recall (finding all relevant entities) and precision (avoiding irrelevant results) - threshold tuning must prioritize avoiding false positives while maintaining good recall

rule: SpecificSearchResultRequirement
@NexusAssistant.searchSpecifications must return specific fragments that precisely match the query intent, providing the exact statement, action, property, or rule that answers the question along with parent entity and referenced entity context for complete understanding

rule: HybridTraceDiscovery
@IntelligentTraceEngine must automatically discover connections between specifications and code without manual tagging by combining embedding-based similarity with LLM reasoning - neither approach alone is sufficient for accurate traceability that users can trust

rule: ExplainableTraceLinks
Every discovered trace link must include a human-readable explanation of why the connection exists, generated by @IntelligentTraceEngine, so developers understand rationale behind traceability

rule: ConfidenceTransparency
@IntelligentTraceEngine must provide confidence scores for all trace links so users understand reliability and can focus review on uncertain traces

rule: ContextualTraceValidation
LLM reasoning must consider full context including entity purposes, relationships, code behavior, and system architecture - not just isolated similarity scores - when validating trace links

rule: ContinuousTraceLearning
@IntelligentTraceEngine must learn from user feedback to continuously improve trace discovery accuracy and reduce false positives over time without requiring manual retraining

rule: MultiHopTraceReasoning
@IntelligentTraceEngine must be capable of following chains of relationships across layers to discover indirect trace links that direct similarity matching cannot find

rule: TraceAmbiguityResolution
When multiple specifications appear similar to code, @IntelligentTraceEngine must use LLM reasoning to disambiguate and identify the correct connection with detailed explanation of why other candidates were rejected
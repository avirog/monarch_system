
catalog: NexusAssistant

entity: NexusAssistant
role: service
purpose:
    - Bridges the gap between product specifications and implementation by providing contextual guidance
    - Rapidly finds and retrieves relevant entities from any layer using deep semantic understanding of questions and specifications
    - Deeply understands entity purposes, properties, actions, and relationships to answer contextual queries with precision
    - Enables product managers to manage requirements and create new features effectively
    - Enables developers to manage system design that supports product needs and to implement features
    - Enables AI agents to understand exact implementation requirements from product and architectural designs
    - Automatically discovers which code implements which specifications using AI analysis
    - Shows developers and product managers how requirements connect to actual implementation
    - Reduces miscommunication between product vision, system design and technical execution

properties:
    productView is @ProductView, collection of product-level views managed by the assistant
    systemDesignView is @SystemDesignView, collection of system design views managed by the assistant
    componentImplementations is @ComponentImplementation, collection of component-level implementations managed by the assistant
    mcpInterface is @MCPServerInterface, protocol interface for external AI agent access

actions:
    provideImplementationContext: Generates @ImplementationContext on-demand by synthesizing product requirements and architectural decisions for specific implementation needs
    analyzeSpecifications: Examines @ProductView and @SystemDesignView to identify gaps, conflicts, or missing details
    traceRequirement: Traces a requirement from @ProductView through @SystemDesignView to @ComponentImplementation and actual source code
    findImplementingCode: Shows which source code files and functions implement a given specification
    findSpecificationForCode: Shows which product requirements and design specs explain why given code exists (traces backward through layers)
    navigateLayers: Provides context following the layered flow: product requirements → design specifications → implementation details
    identifyRelatedEntities: Determines which entities may be affected by changes or are important in a given context
    assessCoverage: Reports which requirements have been implemented and which remain as gaps
    manageRequirements: Helps organize, track, and maintain @ProductView for product managers
    manageSystemDesign: Helps organize, track, and maintain @SystemDesignView for developers
    validateFeatureReadiness: Checks if new feature specifications are complete and ready for design and implementation
    searchSpecifications: Understands natural language questions and finds relevant specifications, entities, and relationships semantically without requiring exact names
    discoverEntities: Lists and explores entities across catalogs, filtered by layer, role, catalog, or context
    exploreEntity: Provides detailed information about a specific entity including its purpose, properties, actions, and relationships
    browseEntityGraph: Enables navigation through the entity relationship graph to understand system structure and dependencies
    findRelevantEntities: Rapidly retrieves contextually relevant entities from any layer by deeply understanding question intent and matching against entity purposes, properties, actions, and relationships
    rankByRelevance: Orders discovered entities by semantic relevance to the question context, considering both direct matches and related entities

entity: ProductManager
role: actor
purpose:
    - Defines product requirements and creates new features in @ProductView
    - Manages the product vision and user-facing capabilities
    - Needs support to ensure specifications are complete and aligned with existing system

properties:
    assistant is @NexusAssistant, the assistant service used for requirements management

actions:
    defineRequirements: Creates and maintains @ProductView for new and existing features
    createFeature: Specifies new features and user capabilities in product views
    queryExistingFeatures: Asks @NexusAssistant about existing product capabilities and implementations
    exploreSystem: Discovers and explores entities to understand existing system structure and capabilities

entity: Developer
role: actor
purpose: 
    - Software engineer who designs system architecture and implements features
    - Creates and maintains @SystemDesignView to support product needs
    - Requires clear, actionable guidance on how to translate product requirements into system design and code

properties:
    assistant is @NexusAssistant, the assistant service used for system design and implementation guidance

actions:
    queryAssistant: Asks @NexusAssistant for system design or implementation guidance on specific features or questions
    designSystem: Creates and maintains @SystemDesignView to support product requirements
    implementFeature: Writes code to implement features based on specifications and guidance received
    exploreSystem: Discovers and explores entities across layers to understand system architecture and dependencies

entity: AIAgent
role: actor
purpose:
    - Autonomous assistant that helps manage product requirements, system design, and code implementation
    - Works across all three layers: product, design, and implementation
    - Needs precise context and constraints to generate appropriate artifacts

properties:
    assistant is @NexusAssistant, the assistant service used for product, design, and implementation guidance

actions:
    manageProductRequirements: Creates and maintains @ProductView based on user needs and business requirements
    manageSystemDesign: Creates and maintains @SystemDesignView to support product requirements
    requestContext: Requests @ImplementationContext from @NexusAssistant for a specific feature
    generateCode: Creates code that meets product and architectural requirements based on provided context
    exploreSystem: Discovers and explores entities to understand system structure before generating specifications or code

entity: ImplementationContext
role: component
purpose:
    - Synthesized guidance that combines product requirements with architectural decisions
    - Provides specific, actionable implementation instructions
    - Generated by @NexusAssistant for @Developer and @AIAgent consumption

entity: ProductView
role: component
purpose:
    - Represents the user-facing features and business capabilities
    - Describes WHAT the system does from customer and business perspective
    - Contains user journeys, business rules, and value propositions
    - Written in Nexus language focusing on WHY features exist

properties:
    systemDesigns is @SystemDesignView, collection of system designs that realize this product

entity: SystemDesignView
role: component
purpose:
    - Represents the technical architecture and system structure
    - Describes HOW the system is organized at high level
    - Contains modules, services, data flows, data struct, schemas, and integration patterns
    - Written in Nexus language focusing on architectural decisions and patterns

properties:
    componentImplementations is @ComponentImplementation, collection of component implementations that realize this design

entity: ComponentImplementation
role: component
purpose:
    - Represents specific code-level components and their implementation details
    - Describes the actual technical implementation of features
    - Contains APIs, data structures, algorithms, and technical constraints
    - Written in Nexus language focusing on concrete implementation requirements

entity: MCPServerInterface
role: service
purpose:
    - Exposes @NexusAssistant capabilities to external AI agents and tools via Model Context Protocol
    - Enables third-party AI systems to query product specifications and system designs
    - Provides standardized protocol interface for both internal and external agent integration
    - Allows external tools to request @ImplementationContext and navigate specification layers

properties:
    exposedOperations is @NexusAssistant, subset of @NexusAssistant actions available through MCP protocol

actions:
    serveMCPRequest: Handles incoming MCP protocol requests from external AI agents
    exposeContext: Provides @ImplementationContext through MCP interface
    exposeNavigation: Enables specification layer navigation for external clients

scenario: DeveloperSeeksImplementationGuidance
Given a developer working on a new feature
When they query the @NexusAssistant with a specific implementation question
Then the assistant analyzes both @ProductView and @SystemDesignView
And shows existing code that implements similar features
And provides contextual implementation guidance 
And includes specific code patterns, constraints, and business logic requirements

scenario: AIAgentGeneratesCode
Given an @AIAgent tasked with implementing a feature
When it requests implementation context from @NexusAssistant
Then the assistant provides structured guidance including:
    - Business rules that must be enforced
    - Technical patterns to follow
    - Integration requirements with existing components
    - Validation and error handling requirements
And the AI agent can generate code that meets both product and architectural requirements

scenario: SpecificationAlignment
Given @ProductView and @SystemDesignView that may have gaps or conflicts
When @NexusAssistant analyzes them
Then it identifies missing implementation details
And highlights potential conflicts between product and design views
And suggests clarifications needed before implementation can proceed

scenario: MultiLayerNavigation
Given a developer or AI agent needs to understand a feature
When they query @NexusAssistant about the feature
Then the assistant provides context across all three layers in sequence:
    - @ProductView: WHY the feature exists and WHAT it does for users
    - @SystemDesignView: HOW the product requirements are translated into technical architecture
    - @ComponentImplementation: Specific technical details and code-level requirements that realize the design
And enables navigation between layers following the product → design → implementation flow

scenario: TraceRequirementToCode
Given a business requirement defined in @ProductView
When a developer needs to implement it
Then @NexusAssistant traces the requirement through @SystemDesignView to specific @ComponentImplementation
And shows which source code files and functions implement which product features
And provides implementation guidance consistent across all three layers

scenario: FindWhyCodeExists
Given a developer looking at unfamiliar code
When they ask @NexusAssistant why this code exists
Then the assistant traces backward from code through @SystemDesignView to @ProductView
And shows the design decisions that translated requirements into this implementation
And reveals the product requirements that justify this code
And explains the business value delivered by this code

scenario: IdentifyImplementationGaps
Given @ProductManager reviewing product roadmap
When they query @NexusAssistant about feature status
Then the assistant shows which requirements are fully implemented
And highlights which requirements have no corresponding code yet
And helps prioritize implementation work based on gaps

scenario: AssessChangeImpact
Given @Developer planning to modify code
When they query @NexusAssistant about potential impacts
Then the assistant identifies which requirements might be affected
And shows which other code depends on the changes
And warns about risks to product features

scenario: ExploratoryNaturalLanguageSearch
Given a developer or product manager unfamiliar with the system
When they ask "What components are responsible for parsing specifications?"
Then @NexusAssistant understands the semantic intent without requiring exact entity names
And searches specifications using meaning and context, not exact text matching
And returns relevant components that handle specification parsing
And explains how these components work together to accomplish parsing

scenario: SemanticLayerDiscovery
Given an @AIAgent exploring the system architecture
When it asks "How does the system expose functionality to AI agents?"
Then @NexusAssistant interprets the question semantically
And identifies design entities related to API exposure and agent integration
And returns components that handle external agent access and their relationships
And provides context about how these components enable integration

scenario: IntentBasedEntitySearch
Given a user asking about capabilities without knowing exact terminology
When they query "Find all entities in the design layer"
Then @NexusAssistant understands they want to browse entities by layer
And retrieves all design-layer entities from the knowledge graph
And presents them with their roles, purposes, and key relationships
And enables further exploration of discovered entities

scenario: FuzzyConceptMatching
Given a query with approximate or alternative terminology
When user asks "What handles file watching?"
Then @NexusAssistant matches concepts like "file watching" to related entities
And finds the component that monitors file changes
And explains the entity's purpose and file watching capability
And shows scenarios demonstrating the file watching behavior

scenario: DiscoverAllEntitiesInCatalog
Given a user exploring an unfamiliar catalog
When they request to see all entities in that catalog
Then @NexusAssistant lists all entities with their roles and brief purposes
And groups entities by layer (product, design, implementation) when relevant
And enables further exploration of any discovered entity

scenario: FilterEntitiesByContext
Given a developer working on a specific feature area
When they request entities related to a particular context (e.g., "authentication" or "payment processing")
Then @NexusAssistant discovers entities semantically related to that context
And shows entities across layers that participate in that domain
And explains how discovered entities connect to form the feature

scenario: ExploreEntityDetails
Given a user who discovered an entity name
When they request detailed information about that entity
Then @NexusAssistant provides the entity's complete definition including purpose, properties, actions
And shows relationships to other entities both incoming and outgoing
And identifies which layer the entity belongs to
And provides navigation to related entities for deeper exploration

scenario: BrowseByLayer
Given a user understanding the system's layered architecture
When they browse entities by layer (product, design, or implementation)
Then @NexusAssistant lists all entities in that layer across all catalogs
And helps users understand the system from a specific perspective
And enables cross-layer navigation to see how layers connect

scenario: DiscoverByRole
Given a user looking for specific types of entities
When they filter by role (actor, service, component, module, etc.)
Then @NexusAssistant discovers all entities with that role
And shows how entities of that role interact within the system
And provides context about each entity's responsibilities

scenario: AccurateContextualEntityRetrieval
Given a developer asks "What entities are involved in processing payment transactions?"
When @NexusAssistant receives this complex contextual question
Then it thoroughly analyzes the question to extract key concepts: "payment", "transactions", "processing"
And searches across both @ProductView and @SystemDesignView comprehensively to ensure no relevant entities are missed
And deeply understands entity purposes, properties, and actions to find accurate semantic matches
And verifies semantic similarity scores meet quality thresholds to avoid false positives
And identifies PaymentFlow in product layer, PaymentGateway in design layer, and all related entities
And ranks results by relevance showing most contextually appropriate entities first with confidence scores
And returns complete, accurate results optimized for speed where possible without compromising correctness

scenario: DeepSemanticUnderstanding
Given a product manager asks "Which features help users recover from errors?"
When @NexusAssistant processes this question
Then it understands "recover from errors" semantically (not just text matching)
And analyzes entity purposes to find those describing error handling, validation, recovery flows
And examines entity actions to identify retry, rollback, or recovery operations
And considers entity relationships to find connected error management capabilities
And returns relevant entities from multiple layers showing complete error recovery ecosystem
And explains how each entity contributes to error recovery

scenario: CrossLayerContextualSearch
Given an @AIAgent asks "What defines and implements user authentication?"
When @NexusAssistant interprets this question
Then it recognizes the question spans both product definition and design implementation
And searches @ProductView for authentication features and user flows
And simultaneously searches @SystemDesignView for authentication components and services
And understands the connections between product requirements and design implementations
And returns unified results showing authentication entities from both layers
And highlights the traceability between product features and technical components
And enables navigation from "what" to "how" seamlessly

scenario: IntelligentEntityRanking
Given multiple entities match a search query
When @NexusAssistant ranks the results
Then it considers semantic similarity to the question
And weights entities with richer purposes and more detailed actions higher
And prioritizes entities with more relationships as they're more central to system
And places entities from the question's target layer (if specified) at the top
And includes related entities that might be indirectly relevant
And presents ranked results with relevance scores explaining why each entity matched

scenario: FastIterativeRefinement
Given a user performs multiple related searches in sequence
When @NexusAssistant handles these queries
Then it maintains context between searches to understand evolving intent
And caches semantic analysis to enable sub-second response times
And learns from which results the user explores to improve relevance
And suggests related entities based on exploration patterns
And enables rapid, fluid discovery through intelligent suggestions

rule: ContextualAccuracy
@NexusAssistant must only provide implementation guidance that is consistent with both product requirements and architectural constraints

rule: TraceabilityRequirement
Every implementation recommendation must be traceable back to specific product requirements or architectural decisions

rule: RealTimeAnalysis
@NexusAssistant must analyze specifications in real-time and provide up-to-date guidance based on the latest versions

rule: MultiPerspectiveIntegration
Implementation context must synthesize both product manager perspective (WHAT/WHY) and architect perspective (HOW) into actionable developer guidance

rule: ThreeLayerConsistency
Information must remain consistent across @ProductView, @SystemDesignView, and @ComponentImplementation layers

rule: LayeredTraceability
Product requirements connect to code through design specifications, never directly - every @ProductView requirement traces through corresponding @SystemDesignView elements to reach @ComponentImplementation and actual code

rule: BidirectionalTraceability
The assistant must support tracing both top-down (from product requirements through design to actual code) and bottom-up (from code through design to product value and business justification)

rule: AutomaticTraceDiscovery
@NexusAssistant must automatically discover connections between specifications and code without requiring manual tagging or linking

rule: CoverageVisibility
Product managers and developers must be able to see which requirements have been implemented and which have gaps

rule: ImpactAwareness
When code or specifications change, @NexusAssistant must identify and communicate what else might be affected

rule: RelationalImpactAnalysis
@NexusAssistant must identify and present all related entities that may be affected by changes or whose relations are important to consider in any context, including implementation, design decisions, product changes, or understanding existing features

rule: SemanticSearchCapability
@NexusAssistant must support natural language queries that don't require exact entity names - searches must understand user intent, match concepts semantically, and return relevant results based on meaning rather than text matching alone

rule: EntityDiscoverability
Users must be able to discover entities without prior knowledge of entity names - @NexusAssistant must provide browsing, filtering, and exploration capabilities by catalog, layer, role, and context to enable understanding of the monitored system

rule: AccuracyOverSpeed
@NexusAssistant must prioritize accuracy and precision of results over response speed - returning the correct, most relevant entities is more important than fast responses, though both should be optimized

rule: RapidSemanticRetrieval
@NexusAssistant should return relevant entities quickly by deeply understanding question intent and semantically matching against entity purposes, properties, actions, and relationships - but speed optimizations must never compromise accuracy or completeness of results

rule: DeepEntityUnderstanding
@NexusAssistant must analyze and understand the complete semantic meaning of each entity including its purpose statements, property descriptions, action definitions, and relationships - not just entity names or keywords

rule: CrossLayerSearch
@NexusAssistant must seamlessly search across @ProductView, @SystemDesignView, and @ComponentImplementation layers simultaneously when questions span multiple perspectives, returning unified results that show connections between layers

rule: IntelligentRelevanceRanking
Search results must be ranked by contextual relevance considering semantic similarity, entity richness, relationship centrality, layer appropriateness, and indirect connections - most relevant entities must appear first with clear relevance explanations

rule: CompleteCoverageOverSpeed
When searching for relevant entities, @NexusAssistant must ensure complete coverage of all potentially relevant entities before applying performance optimizations - missing correct results is worse than slower responses

rule: SemanticPrecision
@NexusAssistant must use appropriate similarity thresholds to balance recall (finding all relevant entities) and precision (avoiding irrelevant results) - threshold tuning must prioritize avoiding false positives while maintaining good recall